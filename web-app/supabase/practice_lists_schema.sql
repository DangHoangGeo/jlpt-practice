-- Practice Lists and Test Records Schema
-- This extends the existing schema with practice lists and test tracking features

-- Practice Lists: User-curated lists of vocab/grammar items to focus on
CREATE TABLE practice_lists (
  id                uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id           uuid        REFERENCES auth.users(id) ON DELETE CASCADE,
  name              text        NOT NULL,
  description       text,
  is_active         boolean     NOT NULL DEFAULT true,
  created_at        timestamptz NOT NULL DEFAULT now(),
  updated_at        timestamptz NOT NULL DEFAULT now(),
  
  UNIQUE(user_id, name)
);

-- Practice List Items: Items within a practice list
CREATE TABLE practice_list_items (
  id                uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  practice_list_id  uuid        REFERENCES practice_lists(id) ON DELETE CASCADE,
  item_id           uuid        NOT NULL,                          -- refers to vocab_items or grammar_items
  item_type         text        NOT NULL CHECK(item_type IN ('vocab','grammar')),
  added_at          timestamptz NOT NULL DEFAULT now(),
  priority          int         NOT NULL DEFAULT 1 CHECK(priority BETWEEN 1 AND 5), -- 1 = low, 5 = high
  
  UNIQUE(practice_list_id, item_id, item_type)
);

-- Test Records: AI-generated personalized tests based on user performance
CREATE TABLE test_records (
  id                uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id           uuid        REFERENCES auth.users(id) ON DELETE CASCADE,
  test_name         text        NOT NULL,
  test_type         text        NOT NULL CHECK(test_type IN ('mock_exam','practice_test','weakness_focus','custom')),
  generated_by      text        NOT NULL DEFAULT 'gemini-1.5-pro',
  generation_prompt text        NOT NULL,                         -- the analysis prompt used
  ai_analysis       jsonb       NOT NULL DEFAULT '{}',            -- AI analysis of user's performance
  difficulty_level  text        NOT NULL CHECK(difficulty_level IN ('easy','medium','hard','mixed')),
  total_questions   int         NOT NULL DEFAULT 0,
  estimated_time_minutes int     NOT NULL DEFAULT 30,
  focus_areas       text[]      DEFAULT ARRAY[]::text[],          -- areas this test focuses on
  created_at        timestamptz NOT NULL DEFAULT now(),
  started_at        timestamptz,
  completed_at      timestamptz,
  score             float,                                        -- percentage score (0-100)
  time_taken_ms     bigint,                                       -- actual time taken
  is_public         boolean     NOT NULL DEFAULT false           -- allow sharing results
);

-- Test Questions: Questions included in a specific test
CREATE TABLE test_questions (
  id                uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  test_record_id    uuid        REFERENCES test_records(id) ON DELETE CASCADE,
  question_id       uuid        NOT NULL,                         -- refers to vocab_questions, grammar_questions, or ai_generated_questions
  question_type     text        NOT NULL CHECK(question_type IN ('vocab','grammar','ai_generated')),
  question_order    int         NOT NULL,                         -- order within the test
  user_answer       text,                                         -- user's selected answer
  correct_answer    text        NOT NULL,                         -- correct answer
  is_correct        boolean,
  time_taken_ms     int,                                         -- time user took for this question
  confidence_level  int         CHECK(confidence_level BETWEEN 1 AND 5),
  answered_at       timestamptz,
  
  UNIQUE(test_record_id, question_order)
);

-- Missing Questions Queue: Items that need questions generated by AI
CREATE TABLE missing_questions_queue (
  id                uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id           uuid        REFERENCES auth.users(id) ON DELETE CASCADE,
  item_id           uuid        NOT NULL,
  item_type         text        NOT NULL CHECK(item_type IN ('vocab','grammar')),
  priority          int         NOT NULL DEFAULT 1 CHECK(priority BETWEEN 1 AND 5),
  status            text        NOT NULL DEFAULT 'pending' CHECK(status IN ('pending','generating','completed','failed')),
  requested_at      timestamptz NOT NULL DEFAULT now(),
  generated_at      timestamptz,
  error_message     text,
  
  UNIQUE(user_id, item_id, item_type)
);

-- Performance Analytics: Detailed analytics for test performance
CREATE TABLE test_analytics (
  id                uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  test_record_id    uuid        REFERENCES test_records(id) ON DELETE CASCADE,
  user_id           uuid        REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Overall performance metrics
  accuracy_rate     float       NOT NULL,                         -- percentage correct
  avg_time_per_question_ms bigint NOT NULL,
  difficulty_rating float       NOT NULL,                         -- AI-calculated difficulty
  
  -- Section-wise performance
  vocab_accuracy    float       DEFAULT 0,
  grammar_accuracy  float       DEFAULT 0,
  vocab_avg_time_ms bigint      DEFAULT 0,
  grammar_avg_time_ms bigint    DEFAULT 0,
  
  -- Weakness identification
  weak_areas        text[]      DEFAULT ARRAY[]::text[],
  strong_areas      text[]      DEFAULT ARRAY[]::text[],
  recommended_focus text[]      DEFAULT ARRAY[]::text[],
  
  -- AI insights
  ai_feedback       jsonb       NOT NULL DEFAULT '{}',            -- detailed AI analysis
  improvement_suggestions jsonb NOT NULL DEFAULT '{}',
  
  created_at        timestamptz NOT NULL DEFAULT now()
);

-- Indexes for performance
CREATE INDEX idx_practice_lists_user ON practice_lists(user_id);
CREATE INDEX idx_practice_list_items_list ON practice_list_items(practice_list_id);
CREATE INDEX idx_practice_list_items_user_type ON practice_list_items(practice_list_id, item_type);
CREATE INDEX idx_test_records_user ON test_records(user_id, created_at DESC);
CREATE INDEX idx_test_records_type ON test_records(test_type, created_at DESC);
CREATE INDEX idx_test_questions_test ON test_questions(test_record_id, question_order);
CREATE INDEX idx_test_questions_performance ON test_questions(test_record_id, is_correct);
CREATE INDEX idx_missing_questions_status ON missing_questions_queue(status, priority DESC);
CREATE INDEX idx_missing_questions_user ON missing_questions_queue(user_id, status);
CREATE INDEX idx_test_analytics_user ON test_analytics(user_id, created_at DESC);
CREATE INDEX idx_test_analytics_test ON test_analytics(test_record_id);

-- Row Level Security
ALTER TABLE practice_lists ENABLE ROW LEVEL SECURITY;
ALTER TABLE practice_list_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE test_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE test_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE missing_questions_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE test_analytics ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can manage own practice lists" ON practice_lists
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own practice list items" ON practice_list_items
  FOR ALL USING (
    practice_list_id IN (
      SELECT id FROM practice_lists WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage own test records" ON test_records
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view public test records" ON test_records
  FOR SELECT USING (is_public = true OR auth.uid() = user_id);

CREATE POLICY "Users can manage own test questions" ON test_questions
  FOR ALL USING (
    test_record_id IN (
      SELECT id FROM test_records WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage own missing questions" ON missing_questions_queue
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own test analytics" ON test_analytics
  FOR ALL USING (auth.uid() = user_id);

-- Auto-update timestamps
CREATE TRIGGER update_practice_lists_updated_at BEFORE UPDATE ON practice_lists
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Functions for test generation
CREATE OR REPLACE FUNCTION generate_personalized_test_questions(
  p_user_id uuid,
  p_test_type text,
  p_question_count int DEFAULT 20,
  p_difficulty text DEFAULT 'mixed'
)
RETURNS TABLE (
  question_id uuid,
  question_type text,
  difficulty_score float,
  user_accuracy float
) AS $$
BEGIN
  -- This function analyzes user performance and returns recommended questions
  -- Implementation would include complex logic based on user_progress, activity_log, etc.
  
  RETURN QUERY
  WITH user_performance AS (
    SELECT 
      up.item_id,
      up.item_type,
      CASE 
        WHEN up.correct_count + up.incorrect_count = 0 THEN 0.5
        ELSE up.correct_count::float / (up.correct_count + up.incorrect_count)
      END as accuracy,
      up.mastery_level,
      up.last_reviewed_at
    FROM user_progress up
    WHERE up.user_id = p_user_id
  ),
  vocab_questions AS (
    SELECT 
      vq.id as question_id,
      'vocab' as question_type,
      COALESCE(up.accuracy, 0.5) as user_accuracy,
      -- Simple difficulty calculation based on user performance
      CASE 
        WHEN up.accuracy IS NULL THEN 0.5  -- New items
        WHEN up.accuracy < 0.3 THEN 0.8    -- Hard for user
        WHEN up.accuracy < 0.7 THEN 0.6    -- Medium for user  
        ELSE 0.4                           -- Easy for user
      END as difficulty_score
    FROM vocab_questions vq
    LEFT JOIN user_performance up ON up.item_id = vq.vocabulary_item_id AND up.item_type = 'vocab'
    ORDER BY 
      -- Prioritize items user struggles with
      CASE WHEN up.accuracy IS NOT NULL THEN up.accuracy ELSE 0.5 END ASC,
      -- Then by how recently reviewed
      COALESCE(up.last_reviewed_at, '1970-01-01'::timestamptz) ASC,
      RANDOM()
    LIMIT p_question_count / 2
  ),
  grammar_questions AS (
    SELECT 
      gq.id as question_id,
      'grammar' as question_type,
      COALESCE(up.accuracy, 0.5) as user_accuracy,
      CASE 
        WHEN up.accuracy IS NULL THEN 0.5
        WHEN up.accuracy < 0.3 THEN 0.8
        WHEN up.accuracy < 0.7 THEN 0.6
        ELSE 0.4
      END as difficulty_score
    FROM grammar_questions gq
    LEFT JOIN user_performance up ON up.item_id = gq.grammar_item_id AND up.item_type = 'grammar'
    ORDER BY 
      CASE WHEN up.accuracy IS NOT NULL THEN up.accuracy ELSE 0.5 END ASC,
      COALESCE(up.last_reviewed_at, '1970-01-01'::timestamptz) ASC,
      RANDOM()
    LIMIT p_question_count / 2
  )
  SELECT * FROM vocab_questions
  UNION ALL
  SELECT * FROM grammar_questions
  ORDER BY difficulty_score DESC, user_accuracy ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
